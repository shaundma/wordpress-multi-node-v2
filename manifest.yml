jpsType: install
jpsVersion: '1.7.2'
id: wordpress-multinode
name: WordPress Multi-Node LEMP Stack
version: 1.2.13
versionDate: 2026-01-28
categories:
  - apps/blogs
  - apps/content-management
  - apps/wordpress
logo: https://raw.githubusercontent.com/shaundma/wordpress-multi-node-v2/main/images/wp-standalone.png
homepage: http://wordpress.org/
description:
  text: WordPress Multi-Node LEMP Stack following Roots.io Trellis architecture. Separate nodes for Nginx+PHP, MariaDB, and Redis for optimal performance and scalability. v1.2.13 - Updated 2026-01-28
  short: WordPress Multi-Node LEMP Stack with separate Nginx+PHP, MariaDB, and Redis nodes

baseUrl: https://raw.githubusercontent.com/shaundma/wordpress-multi-node-v2/main

onBeforeInit: /scripts/beforeInit.js?_r=${fn.random}
onBeforeInstall: /scripts/beforeInstall.js?_r=${fn.random}
nodes: definedInOnBeforeInstall

skipNodeEmails: true

settings:
  fields:
    - caption: PHP version
      type: list
      name: php_engine
      default: php8.4
      required: true
      width: 225
      values:
        - value: php8.4
          caption: PHP 8.4
        - value: php8.3
          caption: PHP 8.3
        - value: php8.2
          caption: PHP 8.2

    - caption: Features
      type: displayfield
      name: displayfield
      markup:

    - caption: Install WordPress
      type: checkbox
      name: wp-addon
      value: true
      disabled: false
      tooltip: "Install WordPress with Bedrock boilerplate. Disable this if you plan to deploy WordPress using your own deployment tools. The environment will still be configured with Nginx, MariaDB, and Redis ready for your deployment."

    - caption: Install WooCommerce
      type: checkbox
      name: woocommerce
      value: false
      disabled: false
      tooltip: "⚠️ Requires 'Install WordPress' to be enabled. WooCommerce is a free open-source e-commerce plugin designed specifically for WordPress. This is a great platform for a store of any size."

    - caption: Install WordPress Multisite Network
      type: checkbox
      name: mu-addon
      value: false
      disabled: false
      tooltip: "⚠️ Requires 'Install WordPress' to be enabled. Multisite is a type of WordPress installation that allows you to create and manage a network of multiple websites from a single WordPress dashboard."

    - caption: ⚠️ COLLABORATION
      type: displayfield
      name: le-warning
      hideLabel: false
      markup: Do NOT enable Let's Encrypt below - it will fail, add SSL add-on manually

    - caption: Install Let's Encrypt SSL with Auto-Renewal
      type: checkbox
      name: le-addon
      value: false
      disabled: false
      tooltip: "Advanced integration with Let's Encrypt certificate authority that simplifies and automates the process of issuing, configuring and updating trusted custom SSL certificates."

    - caption: Install Lightning-Fast Premium CDN
      type: checkbox
      name: cdn-addon
      value: false
      hidden: true
      disabled: false
      tooltip: "Jelastic CDN is an HTTP/3 premium content delivery network of 160+ Super PoPs (points of presence) with bandwidth capacity up to 115 Tbps, advanced caching and acceleration strategies based on best-in-class IP Anycast technology."

    - type: displayfield
      hideLabel: true
      hidden: true
      name: bl_count   
      markup:

mixins:
 - https://raw.githubusercontent.com/shaundma/wordpress-multi-node-v2/main/configs/vers.yml
 - /scripts/common.yml

globals:
  isSingleDeploy: ${settings.isSingleDeploy:true}
  WP_CLUSTER_PATH: https://raw.githubusercontent.com/jelastic-jps/wordpress-cluster/v2.2.0
  DB_USER: ${settings.DB_USER:user-[fn.random]}
  DB_PASS: ${settings.DB_PASS:[fn.password(10)]}
  DB_HOST: sqldb
  REDIS_HOST: nosqldb
  REDIS_PORT: 6379
  PROTOCOL: http
  WP_ADMIN_PASS: ${settings.WP_ADMIN_PASS:[fn.password(10)]}
  SUCCESS: default

onInstall:
  - addLimits
  - addMetadata
  - getUserInfo
  - initLEsettings
  - setupNodes
  - installComposer
  - if (${globals.isSingleDeploy}):
    - setProtocol
    - setDomain
    - getRedisPassword
    - configureRedis
    - install:
        jps: /scripts/events.jps?_r=${fn.random}
        skipEmail: true
    - createUserDB
    - if (${settings.wp-addon:true}):
      - installBedrock
      - setupBedrockNginx
      - if (${settings.mu-addon:false}): installMultisite
      - if (${settings.woocommerce:false}): installWoocommerce
      - install:
          jps: ${globals.WP_CLUSTER_PATH}/scripts/addons.jps?_r=${fn.random}
          skipEmail: true
    - if (!${settings.wp-addon:true}):
      - setGlobals:
          SUCCESS: skeleton
      - setupSkeletonStructure
      - setupBedrockNginx
    - if (${settings.le-addon:false}):
      - installLEaddon
      - if (${settings.wp-addon:true}): setupLEdomain
    - if (${settings.cdn-addon:false}):
      - installCDN
      - if (${settings.wp-addon:true}): setupCDN
    - if ('${settings.success_email}' != 'false'):
      - return:
          type: success
          message: /success/text/success-${globals.SUCCESS}.md?_r=${fn.random}
          email: /success/email/success-nginxphp-${globals.SUCCESS}.md?_r=${fn.random}

actions:

  addLimits:
    - env.nodegroup.ApplyData[cp]:
        data:
          validation:
            maxCount: 1
    - env.nodegroup.ApplyData[sqldb]:
        data:
          validation:
            maxCount: 1
    - env.nodegroup.ApplyData[nosqldb]:
        data:
          validation:
            maxCount: 1

  addMetadata:
    script: |
      var metadata = { project: "${settings.project:default}", projectScope: "${settings.projectScope:production}" };
      return api.env.control.ApplyEnvProperty ?
        api.env.control.ApplyEnvProperty('${env.name}', session, metadata) :
        api.env.control.ApplyNodeGroupData('${env.name}', session, 'cp', metadata);

  getUserInfo:
    script: |
      var resp = jelastic.users.account.GetUserInfo();
      if (resp.result != 0) return resp;

      var email = resp.email || 'admin@example.com';
      var username = email.split('@')[0];

      return {
        result: 0,
        onAfterReturn: {
          setGlobals: {
            WP_ADMIN_USER: username,
            WP_ADMIN_EMAIL: email
          }
        }
      };

  installComposer:
    - log: "Installing Composer"
    - cmd[cp]: |-
        if [ ! -f /usr/local/bin/composer ]; then
          echo "Downloading and installing Composer..."
          wget https://getcomposer.org/download/latest-stable/composer.phar -O /usr/local/bin/composer
          chmod +x /usr/local/bin/composer
          echo "Composer installed successfully"
        else
          echo "Composer already installed"
        fi
        composer --version
      user: root

  setProtocol:
    - script: |
        return {
          result:0,
          ssl: jelastic.billing.account.GetQuotas('environment.jelasticssl.enabled').array[0].value
        }
    - if (${response.ssl} || ${settings.le-addon:false}):
        setGlobals:
          PROTOCOL: https

  setDomain:
    - script: ${globals.WP_CLUSTER_PATH}/scripts/idna.js
      domains: ${env.domain}
    - setGlobals:
        DOMAIN: ${response.domains} 

  installLEaddon:
    - script: |
        return {
          result: 0,
          onAfterReturn: {
            install: {
              jps: "https://github.com/jelastic-jps/lets-encrypt/blob/master/manifest.jps?_r=${fn.random}",
              nodeGroup: "cp",
              skipEmail: true,
              settings: {
                test: false,
                fallbackToX1: true,
                withExtIp: "${globals.isExtIP}"
              }
            }
          }
        };

  initLEsettings:
    - script: |
        return {
          result:0,
          extIP: Boolean(jelastic.billing.account.GetQuotas('environment.externalip.enabled').array[0].value)
        }
    - setGlobals:
        isExtIP: ${response.extIP}

    - cmd[cp]: |-
        [ ! -d /var/lib/jelastic/keys/letsencrypt ] && mkdir -p /var/lib/jelastic/keys/letsencrypt;
        echo "webroot=true" > /var/lib/jelastic/keys/letsencrypt/settings-custom;
        echo "webrootPath=/var/www/webroot/ROOT/current/web" >> /var/lib/jelastic/keys/letsencrypt/settings-custom;
        echo "test=false" >> /var/lib/jelastic/keys/letsencrypt/settings-custom;
        echo "withExtIp=${globals.isExtIP}" >> /var/lib/jelastic/keys/letsencrypt/settings-custom;
      user: root

  setupLEdomain:
    - cmd[cp]: |-
        cd /var/www/webroot/ROOT/current

        # Get the domain from Let's Encrypt settings
        source /opt/letsencrypt/settings

        # Check if multisite - skip search-replace for multisite
        if ! wp core is-installed --network --allow-root; then
          # Get current URLs
          OLD_URL=$(wp option get home --allow-root)
          OLD_DOMAIN=$(echo $OLD_URL | cut -d'/' -f3)
          NEW_URL="https://${domain}"
          NEW_DOMAIN="${domain}"

          echo "Updating WordPress URLs from $OLD_URL to $NEW_URL"

          # Search and replace old URLs with new HTTPS URLs throughout database
          wp search-replace "$OLD_URL" "$NEW_URL" --skip-columns=guid --all-tables --allow-root

          # Also replace short domain (for protocol-relative URLs)
          wp search-replace "$OLD_DOMAIN" "$NEW_DOMAIN" --skip-columns=guid --all-tables --allow-root

          # Update .env file
          sed -i "s|WP_HOME=http://|WP_HOME=https://|g" .env
          sed -i "s|WP_SITEURL=http://|WP_SITEURL=https://|g" .env

          # Flush caches
          wp cache flush --allow-root || true
          wp redis enable --allow-root || true

          echo "WordPress URLs updated to HTTPS successfully"
        else
          echo "Multisite detected - skipping automatic URL update"
        fi

  installCDN:
    - install: https://raw.githubusercontent.com/jelastic-jps/cdn/master/manifest.yml?_r=${fn.random}
      nodeGroup: cp
      skipEmail: true
      settings:
        note: ${settings.noteCDN:}
  
  setupCDN:
    - script: return jelastic.dev.scripting.Eval("c05ffa5b45628a2a0c95467ebca8a0b4", session, "cdn.info", {partnerCode:1})
    - setGlobals:
        CDN_URL: ${globals.PROTOCOL}://${env.envName}-${response.response.partnerCode}.cdn.jelastic.net/
        CDN: ${env.envName}-${response.response.partnerCode}.cdn.jelastic.net
        SUCCESS: cdn
    - install: ${globals.WP_CLUSTER_PATH}/scripts/setupCDN.jps
      skipEmail: true

  installMultisite:
    - log: "Installing WordPress Multisite for Bedrock"
    - install:
        jps: /scripts/installMultisite.jps?_r=${fn.random}
        skipEmail: true
        settings:
          mode: ${settings.mu_mode:subdir}

  setupBedrockNginx:
    - log: "Setting up Trellis Nginx configuration for Bedrock"
    - install: /scripts/setupNginx.jps?_r=${fn.random}
      skipEmail: true

  installBedrock:
    - log: "Installing Bedrock WordPress"
    - install: /scripts/installBedrock.jps?_r=${fn.random}
      skipEmail: true
      settings:
        db_host: ${globals.DB_HOST}
        db_user: ${globals.DB_USER}
        db_pass: ${globals.DB_PASS}
        redis_host: ${globals.REDIS_HOST}
        redis_port: ${globals.REDIS_PORT}
        redis_pass: ${globals.REDIS_PASS}
        wp_admin_user: ${globals.WP_ADMIN_USER}
        wp_admin_pass: ${globals.WP_ADMIN_PASS}
        wp_admin_email: ${globals.WP_ADMIN_EMAIL}
        wp_title: "Hello World"
        wp_url: ${globals.PROTOCOL}://${globals.DOMAIN}

  setupSkeletonStructure:
    - log: "Setting up skeleton directory structure for custom deployment"
    - install: /scripts/setupSkeleton.jps?_r=${fn.random}
      skipEmail: true
      settings:
        db_user: ${globals.DB_USER}
        db_pass: ${globals.DB_PASS}
        db_host: ${globals.DB_HOST}
        wp_url: ${globals.PROTOCOL}://${globals.DOMAIN}
        redis_host: ${globals.REDIS_HOST}
        redis_port: ${globals.REDIS_PORT}
        redis_pass: ${globals.REDIS_PASS}

  setupNodes:
    - log: "Setup Application Node"
    - install: https://raw.githubusercontent.com/jelastic/templates/master/config_v2.jps?_r=${fn.random}
      skipEmail: true
      settings:
        targetGroup: cp
        optimization: wordpress
    - log: "Enable and configure PHP extensions (Redis, igbinary, intl, gd, imagick, OPcache)"
    - cmd[cp]: |-
        # Enable igbinary PHP extension (required by Redis)
        sed -i 's/^;extension=igbinary.so/extension=igbinary.so/' /etc/php.ini

        # Enable Redis PHP extension
        sed -i 's/^;extension=redis.so/extension=redis.so/' /etc/php.ini

        # Enable intl, gd, and imagick extensions
        sed -i 's/^;extension=intl.so/extension=intl.so/' /etc/php.ini
        sed -i 's/^;extension=gd.so/extension=gd.so/' /etc/php.ini
        sed -i 's/^;extension=imagick.so/extension=imagick.so/' /etc/php.ini

        # Verify extensions are enabled
        if grep -q "^extension=igbinary.so" /etc/php.ini; then
          echo "igbinary PHP extension enabled"
        else
          echo "ERROR: Failed to enable igbinary PHP extension"
          exit 1
        fi

        if grep -q "^extension=redis.so" /etc/php.ini; then
          echo "Redis PHP extension enabled"
        else
          echo "ERROR: Failed to enable Redis PHP extension"
          exit 1
        fi

        if grep -q "^extension=intl.so" /etc/php.ini; then
          echo "intl PHP extension enabled"
        else
          echo "ERROR: Failed to enable intl PHP extension"
          exit 1
        fi

        if grep -q "^extension=gd.so" /etc/php.ini; then
          echo "gd PHP extension enabled"
        else
          echo "ERROR: Failed to enable gd PHP extension"
          exit 1
        fi

        if grep -q "^extension=imagick.so" /etc/php.ini; then
          echo "imagick PHP extension enabled"
        else
          echo "ERROR: Failed to enable imagick PHP extension"
          exit 1
        fi

        # Enable and configure OPcache for optimal WordPress performance
        echo "Configuring OPcache for WordPress..."

        # Debug: Show current OPcache lines
        echo "Current OPcache configuration in php.ini:"
        grep -E "zend_extension.*opcache|^;.*zend_extension.*opcache" /etc/php.ini | head -5

        # Enable OPcache extension - try multiple patterns to handle variations
        # Pattern 1: ; zend_extension=/usr/lib64/php/modules/opcache.so
        sed -i 's|^;\s*zend_extension=/usr/lib64/php/modules/opcache.so|zend_extension=/usr/lib64/php/modules/opcache.so|' /etc/php.ini
        # Pattern 2: ;zend_extension=/usr/lib64/php/modules/opcache.so (no space)
        sed -i 's|^;zend_extension=/usr/lib64/php/modules/opcache.so|zend_extension=/usr/lib64/php/modules/opcache.so|' /etc/php.ini
        # Pattern 3: ; zend_extension=opcache (short form)
        sed -i 's|^;\s*zend_extension=opcache|zend_extension=/usr/lib64/php/modules/opcache.so|' /etc/php.ini

        # If still not present, add it
        if ! grep -q "^zend_extension.*opcache\.so" /etc/php.ini; then
          echo "Adding zend_extension line for OPcache..."
          sed -i '/^\[opcache\]/a zend_extension=/usr/lib64/php/modules/opcache.so' /etc/php.ini
        fi

        # Enable opcache.enable setting
        sed -i 's/^;opcache.enable=.*/opcache.enable=1/' /etc/php.ini
        sed -i 's/^;opcache.enable_cli=.*/opcache.enable_cli=0/' /etc/php.ini

        # Configure OPcache settings for WordPress
        sed -i 's/^;opcache.memory_consumption=.*/opcache.memory_consumption=256/' /etc/php.ini
        sed -i 's/^;opcache.interned_strings_buffer=.*/opcache.interned_strings_buffer=16/' /etc/php.ini
        sed -i 's/^;opcache.max_accelerated_files=.*/opcache.max_accelerated_files=10000/' /etc/php.ini
        sed -i 's/^;opcache.validate_timestamps=.*/opcache.validate_timestamps=1/' /etc/php.ini
        sed -i 's/^;opcache.revalidate_freq=.*/opcache.revalidate_freq=2/' /etc/php.ini
        sed -i 's/^;opcache.fast_shutdown=.*/opcache.fast_shutdown=1/' /etc/php.ini

        # Verify OPcache is enabled
        echo "After configuration:"
        grep -E "^zend_extension.*opcache|^opcache.enable" /etc/php.ini | head -5

        if grep -q "^zend_extension.*opcache\.so" /etc/php.ini && grep -E "^opcache.enable\s*=\s*1" /etc/php.ini; then
          echo "OPcache enabled and configured for WordPress"
        else
          echo "ERROR: Failed to enable OPcache"
          echo "Showing relevant lines from php.ini:"
          grep -E "zend_extension.*opcache|opcache.enable" /etc/php.ini | head -10
          exit 1
        fi

        # Deploy PHP configuration files to /etc/php.d/
        echo "Deploying custom PHP configuration files..."

        # Create /etc/php.d if it doesn't exist
        mkdir -p /etc/php.d

        # Download opcache.ini configuration
        wget -O /etc/php.d/opcache.ini ${baseUrl}/configs/php.d/opcache.ini
        if [ -f /etc/php.d/opcache.ini ]; then
          echo "OPcache configuration deployed to /etc/php.d/opcache.ini"
        else
          echo "ERROR: Failed to download opcache.ini"
          exit 1
        fi

        # Download wordpress.ini configuration
        wget -O /etc/php.d/wordpress.ini ${baseUrl}/configs/php.d/wordpress.ini
        if [ -f /etc/php.d/wordpress.ini ]; then
          echo "WordPress PHP configuration deployed to /etc/php.d/wordpress.ini"
        else
          echo "ERROR: Failed to download wordpress.ini"
          exit 1
        fi

        # Restart PHP-FPM to apply changes
        systemctl restart php-fpm
        echo "PHP-FPM restarted with Redis, igbinary, intl, gd, imagick, OPcache, and custom PHP configurations"
      user: root
    - log: "Setup Database Node"
    - cmd[sqldb]: |-
        wget ${baseUrl}/configs/sqldb/wordpress.cnf -O /etc/mysql/conf.d/wordpress.cnf &>> /var/log/run.log || true
        systemctl restart mysql
      user: root
    - log: "Setup Redis Node"
    - cmd[nosqldb]: |-
        # Initial maxmemory will be set dynamically in configureRedis action
        echo "maxmemory-policy allkeys-lru" >> /etc/redis.conf
        systemctl restart redis
      user: root
        
  createUserDB:
    - log: Create user and database
    - cmd[sqldb]: |-
        echo "Setting up database user and creating wordpress database..."

        # Get MySQL root password from Jelastic
        ROOT_PASS=$(awk -F "=" '/password/ {print $2}' /root/.my.cnf 2>/dev/null | tr -d ' ' | tr -d '\n')

        if [ -z "$ROOT_PASS" ]; then
          # Try alternative location
          ROOT_PASS=$(cat /var/lib/jelastic/keys/password.txt 2>/dev/null | tr -d '\n')
        fi

        if [ -z "$ROOT_PASS" ]; then
          echo "ERROR: Could not find MySQL root password"
          exit 1
        fi

        echo "Found MySQL root password"

        # Create wordpress database
        echo "Creating wordpress database..."
        mysql -uroot -p"$ROOT_PASS" -e "CREATE DATABASE IF NOT EXISTS wordpress CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" 2>&1

        if [ $? -eq 0 ]; then
          echo "Database 'wordpress' created successfully"
        else
          echo "ERROR: Failed to create wordpress database"
          exit 1
        fi

        # Verify database exists
        DB_EXISTS=$(mysql -uroot -p"$ROOT_PASS" -e "SHOW DATABASES LIKE 'wordpress';" | grep wordpress)
        if [ -z "$DB_EXISTS" ]; then
          echo "ERROR: Database 'wordpress' does not exist after creation"
          exit 1
        fi
        echo "Verified: Database 'wordpress' exists"

        # Create user and grant privileges
        echo "Creating user ${globals.DB_USER} and granting privileges..."
        mysql -uroot -p"$ROOT_PASS" -e "CREATE USER IF NOT EXISTS '${globals.DB_USER}'@'%' IDENTIFIED BY '${globals.DB_PASS}';" 2>&1
        mysql -uroot -p"$ROOT_PASS" -e "GRANT ALL PRIVILEGES ON wordpress.* TO '${globals.DB_USER}'@'%';" 2>&1
        mysql -uroot -p"$ROOT_PASS" -e "GRANT ALL PRIVILEGES ON *.* TO '${globals.DB_USER}'@'%';" 2>&1
        mysql -uroot -p"$ROOT_PASS" -e "FLUSH PRIVILEGES;" 2>&1

        # Verify user can access the database
        if mysql -u${globals.DB_USER} -p${globals.DB_PASS} -e "USE wordpress; SELECT 1;" 2>&1 | grep -q "1"; then
          echo "Verified: User ${globals.DB_USER} can access wordpress database"
        else
          echo "ERROR: User ${globals.DB_USER} cannot access wordpress database"
          echo "Testing connection details:"
          mysql -u${globals.DB_USER} -p${globals.DB_PASS} -e "SELECT USER(), DATABASE();" 2>&1
          exit 1
        fi

        # Set Jelastic password (this also changes MySQL root password to match)
        jem passwd set -p ${globals.DB_PASS} 2>&1 | grep -i "success"

        # Update .my.cnf with [client] section for passwordless root access
        # This must be done AFTER jem passwd set, as that command overwrites .my.cnf
        # Note: jem passwd set changes the MySQL root password to DB_PASS
        echo "Updating /root/.my.cnf with [client] and [mysql] sections..."
        printf "[client]\nuser=root\npassword=%s\n\n[mysql]\nuser=root\npassword=%s\n\n[mysqladmin]\nuser=root\npassword=%s\n" "${globals.DB_PASS}" "${globals.DB_PASS}" "${globals.DB_PASS}" > /root/.my.cnf
        chmod 600 /root/.my.cnf
        echo "✓ /root/.my.cnf configured with [client], [mysql], and [mysqladmin] sections"

        echo "Database setup completed successfully"
      user: root

  getRedisPassword:
    - log: Get Redis password
    - cmd[nosqldb]: |-
        # Extract Redis password from redis.conf
        REDIS_PASS=$(grep "^requirepass" /etc/redis.conf | awk '{print $2}' | tr -d '\n')

        if [ -z "$REDIS_PASS" ]; then
          echo "ERROR: Could not find Redis password in /etc/redis.conf"
          exit 1
        fi

        echo "$REDIS_PASS"
      user: root
    - script: |
        var output = "${response.out}".trim();
        return {
          result: 0,
          onAfterReturn: {
            setGlobals: {
              REDIS_PASS: output
            }
          }
        }

  configureRedis:
    - log: Configure Redis with dynamic maxmemory
    - script: |
        // Get Redis node info to calculate optimal maxmemory
        var resp = jelastic.environment.control.GetEnvInfo('${env.name}', session);
        if (resp.result != 0) return resp;

        var nodes = resp.nodes;
        var redisNode = null;

        // Find the Redis node
        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].nodeGroup == 'nosqldb') {
            redisNode = nodes[i];
            break;
          }
        }

        if (!redisNode) {
          return {result: 1, error: "Redis node not found"};
        }

        // Calculate maxmemory (80% of allocated RAM)
        // Each cloudlet = 128 MB RAM
        var flexibleCloudlets = redisNode.flexibleCloudlets || 0;
        var fixedCloudlets = redisNode.fixedCloudlets || 0;
        var totalMB = flexibleCloudlets * 128;
        var maxMemoryMB = Math.floor(totalMB * 0.8);

        // Minimum 128MB, use fixed cloudlets if flexible is 0
        if (maxMemoryMB < 128) {
          totalMB = fixedCloudlets * 128;
          maxMemoryMB = Math.floor(totalMB * 0.8);
        }

        return {
          result: 0,
          onAfterReturn: {
            setGlobals: {
              REDIS_INITIAL_MAXMEM_MB: maxMemoryMB
            }
          }
        };

    - log: "Setting Redis maxmemory to ${globals.REDIS_INITIAL_MAXMEM_MB}MB (80% of ${globals.REDIS_INITIAL_MAXMEM_MB * 1.25}MB total RAM)"
    - cmd[nosqldb]: |-
        redis-cli -a ${globals.REDIS_PASS} CONFIG SET maxmemory ${globals.REDIS_INITIAL_MAXMEM_MB}mb
        redis-cli -a ${globals.REDIS_PASS} CONFIG SET maxmemory-policy allkeys-lru
        redis-cli -a ${globals.REDIS_PASS} CONFIG REWRITE
        echo "Initial Redis maxmemory set to ${globals.REDIS_INITIAL_MAXMEM_MB}MB"
      user: root
      
  installWoocommerce:
    - log: "Installing WooCommerce for Bedrock"
    - cmd[${nodes.cp.master.id}]: |-
        cd /var/www/webroot/ROOT/current

        echo "Installing WooCommerce ${globals.version_woocommerce}..."
        composer require wpackagist-plugin/woocommerce:${globals.version_woocommerce} &>> /var/log/run.log

        if [ $? -eq 0 ]; then
          echo "WooCommerce installed successfully"
        else
          echo "ERROR: WooCommerce installation failed"
          exit 1
        fi

        echo "Activating WooCommerce plugin..."
        wp plugin activate woocommerce --allow-root &>> /var/log/run.log

        if [ $? -eq 0 ]; then
          echo "WooCommerce activated successfully"
        else
          echo "ERROR: WooCommerce activation failed"
          exit 1
        fi

        # Fix permissions so WordPress can update the plugin later
        echo "Setting proper permissions for plugin updates..."
        chown -R nginx:nginx /var/www/webroot/ROOT
        find /var/www/webroot/ROOT -type d -exec chmod 755 {} \;
        find /var/www/webroot/ROOT -type f -exec chmod 644 {} \;
        chmod 600 /var/www/webroot/ROOT/shared/.env

        echo "WooCommerce installation complete!"
      user: root

startPage: ${env.url}
