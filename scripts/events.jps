type: update
id: wordpress-standalone-events
name: WordPress Standalone Events

globals:
  WP_CLUSTER_PATH: https://raw.githubusercontent.com/jelastic-jps/wordpress-cluster/v2.2.0
      
onAfterInstallAddon [nodeGroup:cp, id:letsencrypt-ssl-addon]:
  - cmd[cp]: |-
      source /opt/letsencrypt/settings;
      bash ~/bin/setupWP.sh --url https://${domain};

onAfterClone: 
  - install: ${globals.WP_CLUSTER_PATH}/scripts/setupDomain.jps?_r=${fn.random}
    envName: ${event.response.env.envName}
    settings:
      domain: ${event.response.env.domain}

  - script: delete MANIFEST.id; return {result:0, jps:MANIFEST};
  - install: ${response.jps}
    envName: ${event.response.env.envName}  

onBeforeMigrate:
  - cmd[${nodes.cp.master.id}]: wp option get siteurl --path=/var/www/webroot/ROOT | cut -d'/' -f3;
  - if (/${response.out}/.test(env.domain)):
      cmd[${nodes.cp.master.id}]: echo true > ~/migrate
  - else:
      cmd[${nodes.cp.master.id}]: echo false > ~/migrate

onAfterMigrate:
  - cmd[${nodes.cp.master.id}]: if test -f ~/migrate; then cat ~/migrate; fi
  - if (/${response.out}/.test(true)):
    - install: ${globals.WP_CLUSTER_PATH}/scripts/setupDomain.jps?_r=${fn.random}
      settings:
        domain: ${env.domain}

onAfterSetCloudletCount [nodeGroup:nosqldb]:
  - script: |
      // Get Redis node info
      var resp = jelastic.environment.control.GetEnvInfo('${env.name}', session);
      if (resp.result != 0) return resp;

      var nodes = resp.nodes;
      var redisNode = null;

      // Find the Redis node
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].nodeGroup == 'nosqldb') {
          redisNode = nodes[i];
          break;
        }
      }

      if (!redisNode) {
        return {result: 1, error: "Redis node not found"};
      }

      // Calculate maxmemory (80% of flexible cloudlets in MB)
      // Each cloudlet = 128 MB RAM
      var flexibleCloudlets = redisNode.flexibleCloudlets || 0;
      var totalMB = flexibleCloudlets * 128;
      var maxMemoryMB = Math.floor(totalMB * 0.8);

      // Minimum 128MB, use fixed cloudlets if flexible is 0
      if (maxMemoryMB < 128) {
        var fixedCloudlets = redisNode.fixedCloudlets || 2;
        totalMB = fixedCloudlets * 128;
        maxMemoryMB = Math.floor(totalMB * 0.8);
      }

      return {
        result: 0,
        onAfterReturn: {
          setGlobals: {
            REDIS_MAX_MEMORY_MB: maxMemoryMB
          }
        }
      };

  - log: "Updating Redis maxmemory to ${globals.REDIS_MAX_MEMORY_MB}MB after scaling"
  - cmd[nosqldb]: |-
      # Get Redis password
      REDIS_PASS=$(grep "^requirepass" /etc/redis.conf | awk '{print $2}' | tr -d '\n')

      if [ -z "$REDIS_PASS" ]; then
        echo "ERROR: Could not find Redis password"
        exit 1
      fi

      # Update maxmemory
      echo "Setting Redis maxmemory to ${globals.REDIS_MAX_MEMORY_MB}mb"
      redis-cli -a "$REDIS_PASS" CONFIG SET maxmemory ${globals.REDIS_MAX_MEMORY_MB}mb

      # Persist to config file
      redis-cli -a "$REDIS_PASS" CONFIG REWRITE

      # Verify the change
      NEW_MAXMEM=$(redis-cli -a "$REDIS_PASS" CONFIG GET maxmemory | tail -1)
      echo "Redis maxmemory updated successfully to: $NEW_MAXMEM bytes"
    user: root         
